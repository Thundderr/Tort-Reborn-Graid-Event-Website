import { createHmac, timingSafeEqual } from 'crypto';
import { NextRequest, NextResponse } from 'next/server';

// --- Token verification (bot-generated signed tokens) ---

interface TokenPayload {
  discord_id: string;
  discord_username: string;
  discord_avatar: string;
  type: 'guild' | 'community';
  exp: number;
}

/**
 * Verifies a signed token generated by the Discord bot.
 * Token format: base64url(payload).base64url(hmac_sha256_signature)
 */
export function verifyBotToken(token: string): TokenPayload | null {
  const secret = process.env.APPLICATION_TOKEN_SECRET;
  if (!secret) {
    console.error('APPLICATION_TOKEN_SECRET is not set');
    return null;
  }

  const parts = token.split('.');
  if (parts.length !== 2) return null;

  const [payloadB64, signatureB64] = parts;

  try {
    // Compute expected signature
    const expectedSig = createHmac('sha256', secret)
      .update(payloadB64)
      .digest();

    // Decode provided signature
    const providedSig = Buffer.from(signatureB64, 'base64url');

    // Timing-safe comparison
    if (expectedSig.length !== providedSig.length) return null;
    if (!timingSafeEqual(expectedSig, providedSig)) return null;

    // Decode and parse payload
    const payloadJson = Buffer.from(payloadB64, 'base64url').toString('utf-8');
    const payload: TokenPayload = JSON.parse(payloadJson);

    // Check expiration
    if (Date.now() / 1000 > payload.exp) return null;

    // Validate required fields
    if (!payload.discord_id || !payload.discord_username || !payload.type) return null;
    if (payload.type !== 'guild' && payload.type !== 'community') return null;

    return payload;
  } catch {
    return null;
  }
}

// --- Session cookie management ---

interface SessionData {
  discord_id: string;
  discord_username: string;
  discord_avatar: string;
  application_type: 'guild' | 'community';
  exp: number;
}

const COOKIE_NAME = 'app_session';
const SESSION_TTL = 30 * 60; // 30 minutes in seconds

function signPayload(payload: string, secret: string): string {
  return createHmac('sha256', secret).update(payload).digest('base64url');
}

export function setSessionCookie(
  response: NextResponse,
  user: { discord_id: string; discord_username: string; discord_avatar: string },
  applicationType: 'guild' | 'community'
): void {
  const secret = process.env.COOKIE_SECRET;
  if (!secret) throw new Error('COOKIE_SECRET is not set');

  const sessionData: SessionData = {
    discord_id: user.discord_id,
    discord_username: user.discord_username,
    discord_avatar: user.discord_avatar,
    application_type: applicationType,
    exp: Math.floor(Date.now() / 1000) + SESSION_TTL,
  };

  const payloadB64 = Buffer.from(JSON.stringify(sessionData)).toString('base64url');
  const signature = signPayload(payloadB64, secret);
  const cookieValue = `${payloadB64}.${signature}`;

  response.cookies.set(COOKIE_NAME, cookieValue, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    path: '/',
    maxAge: SESSION_TTL,
  });
}

export function getSession(request: NextRequest): SessionData | null {
  const secret = process.env.COOKIE_SECRET;
  if (!secret) return null;

  const cookie = request.cookies.get(COOKIE_NAME);
  if (!cookie) return null;

  const parts = cookie.value.split('.');
  if (parts.length !== 2) return null;

  const [payloadB64, providedSig] = parts;

  try {
    const expectedSig = signPayload(payloadB64, secret);

    // Timing-safe comparison
    const expectedBuf = Buffer.from(expectedSig);
    const providedBuf = Buffer.from(providedSig);
    if (expectedBuf.length !== providedBuf.length) return null;
    if (!timingSafeEqual(expectedBuf, providedBuf)) return null;

    const data: SessionData = JSON.parse(
      Buffer.from(payloadB64, 'base64url').toString('utf-8')
    );

    // Check expiration
    if (Date.now() / 1000 > data.exp) return null;

    return data;
  } catch {
    return null;
  }
}

export function clearSessionCookie(response: NextResponse): void {
  response.cookies.set(COOKIE_NAME, '', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    path: '/',
    maxAge: 0,
  });
}
